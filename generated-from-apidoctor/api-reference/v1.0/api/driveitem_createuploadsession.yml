### YamlMime:GraphOperation
uid: graph.driveitem_createuploadsession
metadata:
  title: Resumable file upload
  author: rgregg
  ms.author: rgregg
  ms.date: 09/10/2017
  content_git_url: https://github.com/microsoftgraph/microsoft-graph-docs/blob/master/api-reference/v1.0/api/driveitem_createuploadsession.md
summary:
  heading: "Upload large files with an upload session"
  intro: |
    Create an upload session to allow your app to upload files up to the maximum file size.
    An upload session allows your app to upload ranges of the file in sequential API requests, which allows the transfer to be resumed if a connection is dropped while the upload is in progress.
    To upload a file using an upload session, there are two steps:
    
    1. [Create an upload session](#create-an-upload-session)
    1. [Upload bytes to the upload session](#upload-bytes-to-the-upload-session)
    
permissions:
  heading: "Permissions"
  intro: |
    One of the following permissions is required to call this API. To learn more, including how to choose permissions, see [Permissions](../../../concepts/permissions_reference.md).
  list:
  - resource: "Delegated (work or school account)"
    permission: "Files.ReadWrite, Files.ReadWrite.All, Sites.ReadWrite.All"
  - resource: "Delegated (personal Microsoft account)"
    permission: "Files.ReadWrite, Files.ReadWrite.All"
  - resource: "Application"
    permission: "Sites.ReadWrite.All"
  outro: |
    ## Create an upload session
    To begin a large file upload, your app must first request a new upload session.
    This creates a temporary storage location where the bytes of the file will be saved until the complete file is uploaded.
    Once the last byte of the file has been uploaded the upload session is completed and the final file is shown in the destination folder.
httpRequest:
  heading: "HTTP request"
  samples:
  - sampleCode: |
      ```http
      POST /drives/{driveId}/items/{itemId}/createUploadSession
      POST /groups/{groupId}/drive/items/{itemId}/createUploadSession
      POST /me/drive/items/{itemId}/createUploadSession
      POST /sites/{siteId}/drive/items/{itemId}/createUploadSession
      POST /users/{userId}/drive/items/{itemId}/createUploadSession
      ```
      
requestHeaders:
  heading: "Optional request headers"
  list:
  - name: "if-match"
    value: "String"
    description: "If this request header is included and the eTag (or cTag) provided does not match the current etag on the item, a 412 Precondition Failed error response is returned."
properties:
  heading: "Properties"
  list:
  - property: "description"
    type: "String"
    description: "Provides a user-visible description of the item. Read-write. Only on OneDrive Personal"
  - property: "fileSystemInfo"
    type: "microsoft.graph.fileSystemInfo"
    description: "File system information on client. Read-write."
  - property: "name"
    type: "String"
    description: "The name of the item (filename and extension). Read-write."
  outro: |
    The response to this request will provide the details of the newly created [uploadSession](xref:graph.uploadsession), which includes the URL used for uploading the parts of the file. 
    
    ```http
    POST /me/drive/root:/{item-path}:/createUploadSession
    Content-Type: application/json
    
    {
      "item": {
        "@odata.type": "microsoft.graph.driveItemUploadableProperties",
        "@microsoft.graph.conflictBehavior": "rename",
        "name": "largefile.dat"
      }
    }
    ```
    
requestBody:
  heading: "Request body"
  intro: |
    No request body is required.
    However, you can specify an `item` property in the request body, providing additional data about the file being uploaded.
    For example, to control the behavior if the filename is already taken, you can specify the conflict behavior property in the body of the request.
    
    ```json
    {
      "item": {
        "@microsoft.graph.conflictBehavior": "rename"
      }
    }
    ```
    
  request:
      heading: "request"
      sampleCode: |
        ```json
        {
          "@microsoft.graph.conflictBehavior": "rename | fail | overwrite",
          "description": "description",
          "fileSystemInfo": { "@odata.type": "microsoft.graph.fileSystemInfo" },
          "name": "filename.txt"
        }
        ```
        
response:
  heading: "Response"
  intro: |
    The response to this request, if successful, will provide the details for where the remainder of the requests should be sent as an [UploadSession](xref:graph.uploadSession) resource.
    This resource provides details about where the byte range of the file should be uploaded and when the upload session expires.
  request:
      heading: "request"
      sampleCode: |
        ```http
        HTTP/1.1 200 OK
        Content-Type: application/json
        
        {
          "uploadUrl": "https://sn3302.up.1drv.com/up/fe6987415ace7X4e1eF866337",
          "expirationDateTime": "2015-01-29T09:21:55.523Z"
        }
        ```
        
  outro: |
    ## Upload bytes to the upload session
    To upload the file, or a portion of the file, your app makes a PUT request to the **uploadUrl** value received in the **createUploadSession** response.
    You can upload the entire file, or split the file into multiple byte ranges, as long as the maximum bytes in any given request is less than 60 MiB.
    The fragments of the file must be uploaded sequentially in order.
    Uploading fragments out of order will result in an error.
    **Note:** If your app splits a file into multiple byte ranges, the size of each byte range **MUST** be a multiple of 320 KiB (327,680 bytes). 
    Using a fragment size that does not divide evenly by 320 KiB will result in errors committing some files.
examples:
- items:
  - request:
      heading: "request"
      sampleCode: |
        ```http
        PUT https://sn3302.up.1drv.com/up/fe6987415ace7X4e1eF866337
        Content-Length: 26
        Content-Range: bytes 0-25/128
        
        <bytes 0-25 of the file>
        ```
        
    response:
      heading: "Response"
      intro: |
        When the request is complete, the server will respond with `202 Accepted` if there are more byte ranges that need to be uploaded.
      sampleCode: |
        ```http
        HTTP/1.1 202 Accepted
        Content-Type: application/json
        
        {
          "expirationDateTime": "2015-01-29T09:21:55.523Z",
          "nextExpectedRanges": ["26-"]
        }
        ```
        
      outro: |
        Your app can use the **nextExpectedRanges** value to determine where to start the next byte range.
        You may see multiple ranges specified, indicating parts of the file that the server has not yet received. 
        This is useful if you need to resume a transfer that was interrupted and your client is unsure of the state on the service.
        You should always determine the size of your byte ranges according to the best practices below. 
        Do not assume that **nextExpectedRanges** will return reanges of proper size for a byte range to upload.
        The **nextExpectedRanges** property indicates ranges of the file that have not been received and not a pattern for how your app should upload the file.
        
        ```http
        HTTP/1.1 202 Accepted
        Content-Type: application/json
        
        {
          "expirationDateTime": "2015-01-29T09:21:55.523Z",
          "nextExpectedRanges": [
          "12345-55232",
          "77829-99375"
          ]
        }
        ```
        
  - request:
      heading: "request"
      sampleCode: |
        ```
        GET https://sn3302.up.1drv.com/up/fe6987415ace7X4e1eF86633784148bb98a1zjcUhf7b0mpUadahs
        ```
        
